---
title: "Programmation fonctionnelle dans dplyr"
author: "Antoine"
date: ""
output: 
  html_document:
    keep_md: true
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(collapse = TRUE)
```

# Le tidyverse et l'évaluation non standard  

La syntaxe du `tidyverse` s'appuie sur des fonctions aux noms explicites et une grande facilité d'utilisation. Le principe est de rendre le code le plus lisible possible. Tout cela permet de coder de manière intuitive et peu verbeuse. Mais lorsqu'il s'agit de coder ses propres fonctions, les choses se compliquent. Prenons par exemple la fonction suivante, qui permet de donner le nombre d'observations d'un dataframe dont une valeur numérique est inférieure à un certain seuil :  

```{r}
library(dplyr)

my_filter <- function(data, x1, seuil){
  data |> filter(x1 <= seuil) |> nrow()
}
```

L'appel de cette fonction pour obtenir le nombre de voitures avec `mpg <= 20` donne l'erreur suivante:  

```{r, error = TRUE}
data(mtcars)

my_filter(mtcars, x1 = mpg, seuil = 20)
```

Cette erreur est la conséquence d'une propriété importante du `tidyverse` : le __data masking__. C'est cette propriété qui fait que les verbes de dplyr évaluent l'appel d'une fonction à un objet au sein du dataframe auquel elle s'applique. Ainsi, on fait appel à des fonctions avec la syntaxe `fonction(data, var1, var2, var3)` et non `fonction(data$var1, data$var2, data$var3)`. Couplé à l'utilisation du _pipe_ (que ce soit le `%>%` de `magritr` ou le récent `|>` de R auquel nous commençons à nous convertir), cette fonctionnalité permet d'obtenir un code bien plus aisé et agréable à écrire et à lire. Ainsi, dans `dplyr`, on considère un peu __le dataframe comme un environnement__ et les colonnes de ce dataframe comme des éléments de cet environnement. 

Seulement voilà, cette évaluation n'est pas non-standard pour rien : ici lors de l'appel de `my_filter` l'objet `mpg` est cherché dans l'environnement et il n'est pas trouvé. Et pour cause : il n'existe pas, contrairement à `mtcars$mpg`. 

# Faire référence aux paramètres de ma fonction   

Comment donc coder comme un développeur de Posit et profiter de cette syntaxe avantageuse? Si les choses ne sont pas aussi simples et intuitives qu'avec base R, elles se sont récemment simplifiées et ne devraient pas vous poser trop de problèmes.  

## Paramètres renseignés en symboles  

Si les paramètres sont renseignés "en dur", ou en symboles, comme c'est le cas dans les verbes de `dplyr`, on privilégiera l'écriture `{{ var }}`. Elle s'est récemment substituée à l'ancienne option, plus énigmatique, de `!!enquo(var)`.   
Testons cela sur notre petite fonction :  
```{r}
my_filter <- function(data, x1, seuil){
  data |> filter({{ x1 }} <= seuil) |> nrow()
}
my_filter(mtcars, x1 = mpg, seuil = 20)
```
Merveilleux! Mais si, pour une raison ou pour une autre, vous souhaiteriez que l'utilisateur de votre fonction entre le paramètre sous forme de chaîne de caractère?

## Paramètres renseignés en chaînes de caractères  
Dans ce cas, on revient à une notation classique de base R : `df[["var"]]`. Sauf que, dans un contexte d'expressions chaînées, on va utiliser la notation bien utile `.data[["var"]]` qui fait référence au dataframe de la chaîne d'expression _dans son état au moment de l'appel__. En effet, si je voulais faire référence au dataframe par son nom je pourrais me retrouver dans cette situation :  

```{r, error = TRUE}
mtcars |> filter(mpg < 20) |> transmute(carb_2 = mtcars[["carb"]]^2) |> head(1)
```
Les tailles des vecteurs ne correspondent pas! En effet, le filtre appliqué n'est pas pris en compte au moment de l'appel à la variable `carb`. La notation `.data` résoud bien ce souci :  
```{r}
mtcars |> filter(mpg < 20) |> transmute(carb_2 = .data[["carb"]]^2) |> head(1)
```

Pour en revenir à notre fonction, il est donc très aisé avec cette notation de définir le paramètre en chaîne de caractères :  

```{r}
my_filter <- function(data, x1, seuil){
  data |> filter(.data[[x1]] <= seuil) |> nrow()
}
my_filter(mtcars, x1 = "mpg", seuil = 20)
```
Mais si vous préférez l'ancienne notation, c'est la suivante et elle marche encore :  
```{r}
my_filter <- function(data, x1, seuil){
  data |> filter(!!sym(x1) <= seuil) |> nrow()
}
my_filter(mtcars, x1 = "mpg", seuil = 20)
```

## Nommer des variables en fonction des paramètres  
Imaginons maintenant que nous voulions créer une indicatrice en fonction du seuil d'une variable numérique, et que nous aimerions nommer cette indicatrice en fonction de la variable numérique qu'elle décrit :  

```{r}
my_indic <- function(data, x1, seuil){
  data |> mutate(x1_indic = if_else({{ x1 }} <= seuil, 1, 0))
}
```

Dans cette version ma nouvelle variable va s'appeler `x1_indic`, et non prendre le nom de la variable numérique de `x1`. Et là encore c'est la double accolade qui va nous permettre de résoudre ce problème, mais pas seulement. Pour cela, on fait référence au nom du paramètre au sein d'une double accolade. De plus, le nom de la variable ainsi créée est donné entre guillemets. On peut également ajouter d'autres caractères. Enfin, __le signe `=` doit être remplacé par `:=`__. Cela donne :  

```{r}
my_indic <- function(data, x1, seuil){
  data |> mutate("{{ x1 }}_indic" := if_else({{ x1 }} <= seuil, 1, 0))
}
```

On vérifie avec `mpg` que la variable `mpg_indic` est bien créé :  

```{r}
my_indic(mtcars, mpg, seuil = 20) |> count(mpg_indic)
```

# Coder une fonction avec n'importe quel nombre de paramètres  
Essayons maintenant d'aller un peu plus loin! On explore dans cette partie des manières plus flexibles de coder nos fonctions, sans fixer à l'avance le nombre de paramètres.  

## L'utilisation d'across  
La solution la plus directe pour permettre à l'utilisateur de votre fonction de définir le nombre de paramètres qu'il souhaite est en général d'utiliser la puissance d'`across()`. On parle de manière détaillée de ce verbe dans [cet article](https://blog.statoscop.fr/fonctionnement-et-performances-dacross-dans-dplyr.html).  
Voyons ici comment vous pouvez vous en servir. Et dans le cas d'une fonction, c'est aussi la syntaxe `{{ var }}` qui nous permettra de l'utiliser. Imaginez par exemple que vous souhaitiez créer une fonction permettant des statistiques sur un certain nombre de variables définies par l'utilisateur. Une telle fonction s'écrirait ainsi :  

```{r}
mean_multiple_var <- function(data, vars_mean){
  data |> summarise(across({{ vars_mean }}, mean))
}
```

On peut ensuite appeler la fonction en définissant le paramètre `vars_mean` comme un vecteur de symboles, ou comme un seul symbole dans le cas où on ne voudrait la moyenne que d'une variable :  

```{r}
mean_multiple_var(mtcars, vars_mean = disp)
mean_multiple_var(mtcars, vars_mean = c(mpg, disp, qsec)) 
```

Si nous souhaitons que l'utilisateur entre un vecteur de chaînes de caractères, cela fonctionne aussi car across utilise la __tidyselection__ qui tolère les appels aux vecteurs de chaînes de caractères. Il faut juste l'encapsuler dans une fonction appropriée, ici `all_of()` pour sélectionner tous les éléments du vecteur :  

```{r}
mean_multiple_var2 <- function(data, vars_mean){
  data |> summarise(across(all_of(vars_mean), mean))
}
mean_multiple_var2(mtcars, vars_mean = c("mpg", "disp", "qsec")) 
```

Enfin, on peut utiliser l'argument `.names` de la fonction `across` pour permettre un renommage des variables au souhait de l'utilisateur :  

```{r}
# L'utilisateur peut choisir le préfixe qu'il souhaite.
# Notez l'utilisation de .col, interne à across(), 
# pour faire référence au nom de la variable
mean_multiple_var2 <- function(data, vars_mean, prefixe = "mean"){
  data |> summarise(across(all_of(vars_mean), mean, .names = "{prefixe}_{.col}"))
}
mean_multiple_var2(mtcars, vars_mean = c("mpg", "disp", "qsec")) 
```


## Autres astuces : pick, any_of...
Quid du group_by, select, etc???


# Références  

[Programming with dplyr](https://dplyr.tidyverse.org/articles/programming.html#user-supplied-data)
[Name injection - rlang](https://rlang.r-lib.org/reference/glue-operators.html)
[Data mask programming patterns](https://rlang.r-lib.org/reference/topic-data-mask-programming.html)